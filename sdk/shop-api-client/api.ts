/**
 * API Spec
 * RESTful JSON API
 *
 * OpenAPI spec version: 1.0.0
 * Contact: test@example.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


import {Client, Service, FetchRequest} from "cyberhck-test";

const BASE_PATH = "http://localhost:5555";
class AuthMiddleware implements IMiddleware < any, any > {
  process(options: FetchRequest, next?: (nextOptions: FetchRequest) => any): any {
    // we check if we have a auth_token
    // if we do, add it to options
    options.headers = {...options.headers, Authorization: 'Bearer: something'};
    // is this auth_token valid (ie not expired?)

    // refresh, we get a new auth_token => save this => continue with the refresh
    return next(options);
  }
}

class ProductsPage extends React.Component{
  @inject
  constructor(api: ProductsApi){
    api.productsDetail()
  }
}

export class BaseAPI extends Service {
  @inject
  constructor(client: Client) {
    super(client);
  }

  protected bakeUrl(raw: string, params: {[key:string]: any}) {
    Object.keys(params).forEach((key) => {
      raw.replace("{" + key + "}", params[key])
    });
    return raw;
  }
}

/**
 * Auth token
 */
export interface Auth {
    /**
     * Short lived JWT Token
     */
    "accessToken"?: string;
    /**
     * Refresh token to delegate new access_token
     */
    "refreshToken"?: string;
    "tokenType"?: AuthTokenTypeEnum;
    "grantType"?: AuthGrantTypeEnum;
    /**
     * Number of seconds after which access_token expires
     */
    "expiresIn"?: number;
}

export type AuthTokenTypeEnum = "Bearer";
export type AuthGrantTypeEnum = "password" | "auth_key" | "refresh_token";
/**
 * Authentication response payload
 */
export interface Authentication {
    "data": Auth;
    /**
     * Optional arbitrary meta data (key/value pairs)
     */
    "meta"?: any;
    /**
     * Unique UUID for each request
     */
    "requestId": string;
}

/**
 * Category details
 */
export interface Categories {
    /**
     * Primary identifier
     */
    "id"?: number;
    /**
     * The category image URI
     */
    "image"?: string;
    /**
     * Last modified date time with timezone
     */
    "lastModified"?: string;
}

/**
 * Category details response payload
 */
export interface CategoriesDetail {
    "data": Categories;
    /**
     * Optional arbitrary meta data (key/value pairs)
     */
    "meta"?: any;
    /**
     * Unique UUID for each request
     */
    "requestId": string;
}

/**
 * Categories list response payload
 */
export interface CategoriesList {
    /**
     * Categories list
     */
    "data": Array<Categories>;
    /**
     * Optional arbitrary meta data (key/value pairs)
     */
    "meta"?: any;
    /**
     * Unique UUID for each request
     */
    "requestId": string;
}

/**
 * Error response
 */
export interface ErrorResponse {
    "errors": Array<ErrorUnit>;
    /**
     * Optional arbitrary meta data (key/value pairs)
     */
    "meta"?: any;
    /**
     * Unique UUID for each request
     */
    "requestId": string;
}

export interface ErrorUnit {
    /**
     * The error code
     */
    "code": number;
    /**
     * The error description
     */
    "message": string;
    /**
     * The erroneous data field (if any)
     */
    "field"?: string;
}

/**
 * Product details
 */
export interface Products {
    /**
     * Primary identifier
     */
    "id"?: number;
    /**
     * Product model aka SKU
     */
    "model"?: string;
    /**
     * Product popularity in a range of 0 - 10
     */
    "currentPopularity"?: number;
    /**
     * Product marked price
     */
    "price"?: number;
}

/**
 * Product details response payload
 */
export interface ProductsDetail {
    "data": Products;
    /**
     * Optional arbitrary meta data (key/value pairs)
     */
    "meta"?: any;
    /**
     * Unique UUID for each request
     */
    "requestId": string;
}

/**
 * Products list response payload
 */
export interface ProductsList {
    /**
     * Products list
     */
    "data": Array<Products>;
    /**
     * Optional arbitrary meta data (key/value pairs)
     */
    "meta"?: any;
    /**
     * Unique UUID for each request
     */
    "requestId": string;
}

/**
 * Zone details
 */
export interface Zones {
    /**
     * Primary identifier
     */
    "id"?: number;
    /**
     * Name of zone
     */
    "name"?: string;
    /**
     * Unique code
     */
    "code"?: string;
    /**
     * Country ID where the zone belongs to
     */
    "countryId"?: number;
}

/**
 * Zone details response payload
 */
export interface ZonesDetail {
    "data": Zones;
    /**
     * Optional arbitrary meta data (key/value pairs)
     */
    "meta"?: any;
    /**
     * Unique UUID for each request
     */
    "requestId": string;
}

/**
 * Zones list response payload
 */
export interface ZonesList {
    /**
     * Zones list
     */
    "data": Array<Zones>;
    /**
     * Optional arbitrary meta data (key/value pairs)
     */
    "meta"?: any;
    /**
     * Unique UUID for each request
     */
    "requestId": string;
}



export class AuthApi extends BaseAPI {
  public authentication(options?: FetchRequest): Promise<Authentication> {
    const queryParameters = {
    };
    let body = null;

    return this.client.process({...{url: "/auth", method: "POST", queryParameters, body}, ...options} as FetchRequest);
  }
  public delegation(params: {  "authorization": string; }, options?: FetchRequest): Promise<Authentication> {
    const queryParameters = {
    };
    let body = null;

    return this.client.process({...{url: "/auth/delegation", method: "POST", queryParameters, body}, ...options} as FetchRequest);
  }
}

export class BanksApi extends BaseAPI {
  public getBankName(params: {  "code": string; }, options?: FetchRequest): Promise< any > {
    const queryParameters = {
    };
    let body = null;

    return this.client.process({...{url: this.bakeUrl("/banks/{code}", params), method: "GET", queryParameters, body}, ...options} as FetchRequest);
  }
}

export class CategoriesApi extends BaseAPI {
  public categoriesDetail(params: {  "id": number; }, options?: FetchRequest): Promise<CategoriesDetail> {
    const queryParameters = {
    };
    let body = null;

    return this.client.process({...{url: this.bakeUrl("/categories/{id}", params), method: "GET", queryParameters, body}, ...options} as FetchRequest);
  }
  public categoriesList(options?: FetchRequest): Promise<CategoriesList> {
    const queryParameters = {
    };
    let body = null;

    return this.client.process({...{url: "/categories", method: "GET", queryParameters, body}, ...options} as FetchRequest);
  }
}

export class ProductsApi extends BaseAPI {
  public productsDetail(params: {  "id": number; "search": string; }, options?: FetchRequest): Promise<ProductsDetail> {
    const queryParameters = {
        "search": params["search"],
    };
    let body = null;

    return this.client.process({...{url: this.bakeUrl("/products/{id}", params), method: "GET", queryParameters, body}, ...options} as FetchRequest);
  }
  public productsList(options?: FetchRequest): Promise<ProductsList> {
    const queryParameters = {
    };
    let body = null;

    return this.client.process({...{url: "/products", method: "GET", queryParameters, body}, ...options} as FetchRequest);
  }
}

export class ZonesApi extends BaseAPI {
  public zonesCreate(params: {  "data": Zones; }, options?: FetchRequest): Promise<ZonesDetail> {
    const queryParameters = {
    };
    let body = null;
    options.headers = {"Content-Type": "application/json", ...options.headers};
    if (params["data"]) {
      body = JSON.stringify(params["data"] || {});
    }

    return this.client.process({...{url: "/zones", method: "POST", queryParameters, body}, ...options} as FetchRequest);
  }
  public zonesDelete(params: {  "id": number; }, options?: FetchRequest): Promise< any > {
    const queryParameters = {
    };
    let body = null;

    return this.client.process({...{url: this.bakeUrl("/zones/{id}", params), method: "DELETE", queryParameters, body}, ...options} as FetchRequest);
  }
  public zonesDetail(params: {  "id": number; }, options?: FetchRequest): Promise<ZonesDetail> {
    const queryParameters = {
    };
    let body = null;

    return this.client.process({...{url: this.bakeUrl("/zones/{id}", params), method: "GET", queryParameters, body}, ...options} as FetchRequest);
  }
  public zonesList(options?: FetchRequest): Promise<ZonesList> {
    const queryParameters = {
    };
    let body = null;

    return this.client.process({...{url: "/zones", method: "GET", queryParameters, body}, ...options} as FetchRequest);
  }
  public zonesUpdate(params: {  "id": number; "data": Zones; }, options?: FetchRequest): Promise<ZonesDetail> {
    const queryParameters = {
    };
    let body = null;
    options.headers = {"Content-Type": "application/json", ...options.headers};
    if (params["data"]) {
      body = JSON.stringify(params["data"] || {});
    }

    return this.client.process({...{url: this.bakeUrl("/zones/id", params), method: "PUT", queryParameters, body}, ...options} as FetchRequest);
  }
}
